# 実装の進捗

## 第一回

Rustの勉強のために、そして計算機というものを少しでも理解するために、Rustでゲームボーイのエミュレータを実装することにしました。

とりあえず見たサイトは[これ](https://keichi.dev/post/write-yourself-a-game-boy-emulator/)

主なドキュメントと方針が書かれているので、それを参考に作っていきます。  
ドキュメントについては[こちら](https://github.com/gbdev/awesome-gbdev)も詳しいです。

### 情報収集

[Game Boyについての有名な解説動画](https://media.ccc.de/v/33c3-8029-the_ultimate_game_boy_talk)を見て、ほーん分かったような分からんようなになりました。まず早口なので英語を理解するのが結構難しい。

[もう一つの基礎的な動画](https://www.youtube.com/playlist?list=PLu3xpmdUP-GRDp8tknpXC_Y4RUQtMMqEu)の方が初心者には良いかも。特に自作OSとかでCPUやアセンブリの基本的な知識を持っていない人はこちらをおすすめします。

### ROM読み取り

まずは何から手を付けようかと思ったが、先人がROMの読み取りから手を付けていたのにならい、ROMを読み出してくる部分から書くことにし、
[Pan DocsのROM説明部分](https://gbdev.io/pandocs/The_Cartridge_Header.html)を読みます。

読んだ結果どうもメモリマップの話とかをまず理解しなければならないねということがわかったので、まとめることに......。

#### Game Boyのメモリ戦略

前提として、Game Boyには8KiBのRAMと8KiBのVRAMが搭載されています......これが2003年まで製造販売されてたってマジ？ 翌年発売のDSは4MB RAMを搭載しているんですが。というかDSが4MBなのもすごいね。

まあそんなことはいいや。さて、Game Boyに搭載されているCPUには16bitのメモリバスが存在するので、64KiBまでのメモリアドレスを扱うことができます。RAM 8KiB + VRAM 8KiB = 16KiB なので、64KiB - 16KiB = 48KiB余りますね。その余った分をROMの読み込みやデバイスアクセス、スプライトの管理等に使用します。

以下は詳細なメモリマップです。[Pan Docs](https://gbdev.io/pandocs/Memory_Map.html)から引っ張ってきました。

| 開始位置  | 終了位置 | 内容                            | 備考                                                                  |
| -------- | -------- | ------------------------------ | --------------------------------------------------------------------- |
| 0000     | 3FFF     | 16 KiB ROM Bank 00              | バンク0(カートリッジ最初の16KiB)で固定                                 |
| 4000     | 7FFF     | 16 KiB ROM Bank 01~NN          | MBCによってバンクを切り替え可能                                       |
| 8000     | 9FFF     | 8 KiB Video RAM (VRAM)         | 画面表示に使用。ゲームボーイカラーではバンク切り替え可能              |
| A000     | BFFF     | 8 KiB External RAM             | カートリッジに増設されたRAMをコントロールする領域。バンク切り替え可能 |
| C000     | CFFF     | 4 KiB Work RAM (WRAM)          | メインメモリ                                                          |
| D000     | DFFF     | 4 KiB Work RAM (WRAM)          | メインメモリ。ゲームボーイカラーではバンク切り替え可能                |
| E000     | FDFF     | C000~DDFFのミラー (ECHO RAM)   | C000 から DDFF を読み込んだ時と同じ内容が出現する                     |
| FE00     | FE9F     | Sprite attribute table (OAM)   | スプライトの管理を行う領域                                            |
| FEA0     | FEFF     | Not Usable                     | Nintendoが使用を禁止している領域                                      |
| FF00     | FF7F     | I/O Registers                  | デバイスアクセス時に使用                                              |
| FF80     | FFFE     | High RAM (HRAM)                | スタック用の領域                                                      |
| FFFF     | FFFF     | Interrupt Enable register (IE) | 割り込みの有効/無効を切り替える                                        |

今回注目するべきなのは上二つです。そもそもROMにアクセスするアドレスが32KiBしか割り当てられていません。これは極めて狭い範囲です。  
ROM容量が32KiB以内に収まるのはテトリスのような極めてシンプルなゲームくらいで、ほとんどのゲームは32KiBを超過してしまいます。

例えばポケモン赤緑の国内版ROMの容量は512KiBですし、海外版に至ってはちょうど1MiBだそうです。どうやったってメモリバスが足りません。  
素直にやれば、最初の32KiB以降のROMの中身にアクセスすることは出来ないということになります。これはとても困りますね。

それを解決するためのTrickがMBCs, Memory Bank Controllersです。

Trickの方針はこうです。

1. 大きなROMを16KiBごとの区画に切り分ける
2. その区画に対し、前から0-indexedで番号を割り振る
3. 番号を指定すると、その番号が振られた区画のデータがMBCによって0x4000 ~ 0x7FFFの範囲にマッピングされる

この機能を使用することで、ROM上の任意の場所にあるデータを読み込むことが出来るようになります。

ところでMBCsは本来ROMカートリッジ内に実装されているチップで、厳密にいえばGame Boyの本体そのものには存在しないチップなのですが、これから作るのは物理カートリッジを扱わないエミュレータなので当然実装する必要があります。

#### Re:ROM読み取り

というわけでROM読み取りの実装に帰ってきました。張り切ってMBCを実装していく......のは少し辛いです。MBCにも色々な種類があり、それらを一つ一つ実装していくのは骨が折れます。  
出来なくはないでしょうが、一ヶ月使ってようやくROM読み取り部分が完成、みたいなことになってしまうでしょう。このような進め方ではモチベーションが萎びてしまう自信があります。

よって、今の段階では最も簡単なNo MBCのみに対応することにします。No MBCとはROMの中身を直接そのまま0x0000 ~ 0x7FFFにマッピングするだけの、最も単純なメモリ戦略です。
つまり、32KiBよりも大きいROMを扱うのは一旦後回しということですね。

インクリメンタルに進めていくのは大きいソフトウェアを作っていくうえでの定石ですし、また大きなROMを扱いたくなった時に戻ってくるとしましょう。

#### ROM読み込みの実装

とりあえずRomのヘッダ情報を格納します。rom.rsを作りました。Rust完全初心者なので[先駆者の実装](https://github.com/mj-hd/gb/)を参考に実装しています。便利な言語仕様が多すぎてちょっとびっくりしますね。

RustのドキュメントやGame Boyのドキュメントとにらめっこしながら手を動かすと読み取りは終わりました。考える時間よりは調べる時間の方がずっと長かったですね。

#### MBCの実装

MBCは、つまるところCPUのメモリバスとROMの仲立ちをするものなので、メモリバスのことも考えながら実装する必要があります。  
少し考えることが多くて厄介ですが、以下の要件を満たすように作れば良いと考えました。

- MBCのタイプによって挙動を切り替えることが出来る -> メソッドは共通になりそうなのでtraitを定義するのが良いかな？
- 必要なメソッドは以下の通り？

1. ROM-Reading
2. RAM-Reading
3. ROM-Writing (ROM-bankへの書き込み)
4. RAM-Writing

こんなもんですかねえと思いながら[先人の初期実装](https://github.com/mj-hd/gb/commit/e8a8b65d05c43b2c38bf627bb19be8f2e7299f1c)を覗いてみると大体同じだったので、実装していきます。とはいえNo MBCしか実装しないのでまあ楽。

Traitって何？ `impl Trait`と`impl Trait for struct`の意味するところが違うってどういうこと？ とか思いながら必死でRustのドキュメントを読みながら実装しました。出来るだけ写経せず、どうしても詰まった時だけ先人のコードを見るようにしましたが、想定より内容が一致しました。方針の立て方は合っているということなのでまあ良いことなのかなと。

とりあえず今回はここで終わり。次はメモリバスとCPUかなあ。

## 第二回

とりあえずメモリバスを書きます。以下にメモリマップを再掲。

| 開始位置  | 終了位置 | 内容                            | 備考                                                                  |
| -------- | -------- | ------------------------------ | --------------------------------------------------------------------- |
| 0000     | 3FFF     | 16 KiB ROM Bank 00              | バンク0(カートリッジ最初の16KiB)で固定                                 |
| 4000     | 7FFF     | 16 KiB ROM Bank 01~NN          | MBCによってバンクを切り替え可能                                       |
| 8000     | 9FFF     | 8 KiB Video RAM (VRAM)         | 画面表示に使用。ゲームボーイカラーではバンク切り替え可能              |
| A000     | BFFF     | 8 KiB External RAM             | カートリッジに増設されたRAMをコントロールする領域。バンク切り替え可能 |
| C000     | CFFF     | 4 KiB Work RAM (WRAM)          | メインメモリ                                                          |
| D000     | DFFF     | 4 KiB Work RAM (WRAM)          | メインメモリ。ゲームボーイカラーではバンク切り替え可能                |
| E000     | FDFF     | C000~DDFFのミラー (ECHO RAM)   | C000 から DDFF を読み込んだ時と同じ内容が出現する                     |
| FE00     | FE9F     | Sprite attribute table (OAM)   | スプライトの管理を行う領域                                            |
| FEA0     | FEFF     | Not Usable                     | Nintendoが使用を禁止している領域                                      |
| FF00     | FF7F     | I/O Registers                  | デバイスアクセス時に使用                                              |
| FF80     | FFFE     | High RAM (HRAM)                | スタック用の領域                                                      |
| FFFF     | FFFF     | Interrupt Enable register (IE) | 割り込みの有効/無効を切り替える                                        |

ROMは前回MBCとかも書いたのでアクセスできますね。RAMもまあ配列を持てばいいでしょう。  
VRAMはPPUとかが絡んできそうなので今はよくわかんないです。OAMもまだだし、I/Oも割り込みもまだ。HRAMくらいは持っても良いのか？ -> 先人の実装を見る限り良さそう。

とりあえずreadとwriteを実装すれば良いでしょう。というわけでやった。そんなに難しいことはしていません。

TODO: この時点でのGitのコミットを貼り付ける

### ところでBox\<dyn Trait\>って何？マジで

Traitを引数に取ろうとしてもエラーが出てしまい、公式ドキュメントを見て`fn new(mbc: &impl Mbc) -> Self` みたいなコードを書いてもダメでした。

先駆者の実装をカンニングした結果`Box<dyn Mbc>`みたいなコードを書くことで解決したんですが、これが何をやっているのか全然わからない。

色々調べた結果、Rustのコンパイラは関数の引数や戻り値のサイズ――これはメモリ上に置いた時のバイト数的な意味――を明確化することを我々に求めており、Traitのように実行時にサイズが変わり得るものを記述するには一工夫を要するということが分かりました。

`dyn`はdynamicの意であり、Traitの型は実行時に決定されることを明示するsyntaxのようです。そして`Box`は変数をスタック領域ではなくヒープ領域に置き、その参照をスタック領域に保存させる記法であることが分かりました([参照](https://doc.rust-jp.rs/rust-by-example-ja/std/box.html))。  

こうすることで少なくともスタック領域に保存される値のサイズは静的に確定しますね。Rustでは全ての値がデフォルトでスタックに割り当てられることにまずびっくりです。メモリの気持ちになる必要があるということが、分かりました......。

## 第三回

「CPUを書くわよ！キョン！」

エミュレータ実装といえばこれだよねという作業に入っていきます。いよいよ本番ですわね。色々と分からないことが多いのでまとめていきます。

### Game BoyのCPUについて

大体[Pan Doc](https://gbdev.io/pandocs/CPU_Registers_and_Flags.html)と[この神PDF](http://marc.rawer.de/Gameboy/Docs/GBCPUman.pdf)の61ページからを読みました。

Game BoyのCPUのアーキテクチャは上記を始めとした様々なところで紹介されているので有名かと思いますが、整理のため以下に記載しておきます。

そもそもCPUの構成要素って何が要るの？クロックとかレジスタとかって何？みたいな話をすると思います。

#### レジスタ

i8bit、つまり0から255までの値を保持できるレジスタは `A, B, C, D, E, F, H, L` の八つが存在し、  
16bit、つまり0から65535までの値を保持できるレジスタは `SP, PC` の二つが用意されています。以下はそれを示した表です。

|       |       |
| :---: | :---: |
|   A   |   F   |
|   B   |   C   |
|   D   |   E   |
|   H   |   L   |
|   SP  |       |
|   PC  |       |

ただし `AF, BC, DE, HL` のように、二つの8bitレジスタを一つの16bitレジスタとしても扱うことが出来ます。

|       |       |
| :---: | :---: |
|   AF  |       |
|   BC  |       |
|   DE  |       |
|   HL  |       |
|   SP  |       |
|   PC  |       |

特殊なレジスタについて私の分かる範囲で雑に書いておくと、

Aレジスタ: 何か数値計算するときはここを使う
Fレジスタ: 直前の数値計算の結果が反映される。具体的には、直前の計算結果が0だったら7bit目が立つなど
PCレジスタ: 次に実行する命令のメモリ位置を格納する
SPレジスタ: スタックにおける現在位置を格納する

らしい。

まあ、全体的にふーんという感じですね。

あと幾つかあるけど[Pan Doc](https://gbdev.io/pandocs/CPU_Registers_and_Flags.html)を見れば概略はつかめると思います。

### clock cycleについて

ドキュメントにあるCPUの命令表を見ていると `Clock cycles` という欄があります。これはその命令を実行するのに何回のクロックサイクルを必要とするかを示した値です。
当たり前のことなのですが、普通我々が利用しているPCに搭載されたCPUの計算速度はゲームボーイに搭載されていたそれよりも遥かに高速です。これをそのまま動作させると、例えば画面描画などが異常更新されて大変なことになります。明らかに正常な動作はしないように思えますね。

この問題を解決するため、各命令のサイクル数をもとにエミュレータの動作速度を実機のそれと同期させます。

具体的な話をしましょう。普通の――SGBやGBCなどではない――ゲームボーイに搭載されているCPUのClock cycleは`4.194304MHz`です。単位をヘルツにすると`4194304Hz`ですね。つまり一秒間に4194304回のサイクルを実行することが出来ます。

一方で、ゲームボーイのFPS――frames per second, 一秒間に画面を更新する回数――はおおよそ`60Hz`です。厳密には`59.73Hz`だとか`59.72Hz`だとからしいですが、一旦60として話を進めます。

さて、計算をしましょう。`4194304 // 60 = 69905`です。つまり一秒間に六十回の頻度で69905サイクルを処理し、画面描画を実行してあげれば良いということになります。

定期実行ということでjsのsetInterval概念を使った疑似コードを以下に記述しました。

```js
setInterval(() => {
    const maxCycle = 69905;
    let currentCycle = 0;

    while (currentCycle < maxCycle) {
        // 69905サイクルを処理する
        const cycle = getNextOperationCycle();
        currentCycle += cycle;
        // 色々と処理を実行
    }

    // 画面を描画する
    renderScreen();
}, 1000 / 60)

```

実機に近い動作をさせるには、このような工夫を実装することが必要になるということが分かりましたね。

### 実装すること

CPUにおいてやることは大まかに

1. 命令を取ってくる
2. 命令をデコードする
3. 命令を実行する

の三つをひたすらループすることです。

#### 命令を取ってくる

命令は当然ゲームソフトのROMから取ってくるのですが、命令を読み出すアドレスはPCレジスタに保存し、更新していきます。実機のゲームボーイを起動するとPCレジスタは`0x100`に初期化されます。これはROMのエントリーポイントとなっており、そこからゲームプログラム本体が記述されているアドレス――大抵は`0x150`らしい――にジャンプするという構造になっているようです。

PCレジスタの更新ですが、特段の命令がない限りは単純にインクリメントしていき、ジャンプ命令などの際には直接書き換えてあげる、という挙動にすれば良さそうです。

#### 命令をデコードする

[この神PDF](http://marc.rawer.de/Gameboy/Docs/GBCPUman.pdf)の命令セットの部分を眺めると、Opcodeという欄があります。これは命令コードで、「このコードが来たらこの命令を行う」ということを示しています。

#### 命令を実行する

気合で分岐。大体五百個くらいあるらしいです。ウッス。

あとはどうせデバッグをする必要があるので、ブレークポイント張ったりステップ実行したりはあらかじめ入れ込んでおいた方が良さそうですね。

### いくつか踏んだ罠とか気を付けることとか

列挙していきます。

1. メソッドをpubにしていなかったせいで半日溶かした。プログラミング初心者か？
2. CPU命令で`(HL)`みたいに括弧でくくられているものの意味が分からなかった。括弧でくくられているレジスタが格納する値をメモリアドレスとして扱い、そのアドレスに格納されている値を扱うということらしい。本当に自作OSやってたんですか？
3. 基本的にリトルエンディアンなので、low -> highの順で読み書きするよう実装しましょう
4. stackはアドレスが大きい方から小さい方へと伸びていきます。pushするときはSPをデクリメントし、popするときはSPをインクリメントしましょう
5. 純粋に500命令近く書くのが面倒。本当に。面倒です。かといってYoutubeとか見ながらやると注意散漫になってミスるので気を付けてください
6. half carryってなに？って思ったけど、3bit目で繰り上がりが起きているかどうかを調べればよい -> `(0x0F & left) + (0x0F & right) == 0x10` をします。普通のcarryも同じ要領で。16bit版も同じ
7. 本当に命令を書くのが面倒くさいです。命令の並びにはある程度規則性があるので多少は削減できますが、非自明な場合分けが増えるし、例外も怖いしで結局全部書いています
8. やっぱりちょっとだけ規則に対して一般化しました
9. ふと自分のコードを見返してみたら、ほとんど参照使わずにムーブしててヤバくね？となりました。実際プリミティブ型だったので自動的にコピーされてI got a Kotonakiをしましたが、気を付ける必要がありますね
10. DAA命令って何？ -> [二進化十進表現(BCD)](https://ja.wikipedia.org/wiki/%E4%BA%8C%E9%80%B2%E5%8C%96%E5%8D%81%E9%80%B2%E8%A1%A8%E7%8F%BE)というおもしろ表現があるので、Aレジスタに入っている二進数の値をそれに変換します。なおNフラグが立っているかどうか、Cフラグが立っているかどうか、Hフラグが立っているかどうかで場合分けがつらいことになるので、[参考資料](https://forums.nesdev.org/viewtopic.php?t=15944)を見てやるのがおすすめ。
11. STOP命令が2バイトになっている資料がたまに存在するが、どうもこれはGB実機側のバグで、STOPの後にNOPを入れなければ実機では動作しなかったらしい。どうせ00はNOPなので先頭1バイトだけ読めばよい
12. RLCA命令とRLA命令って何が違うんですか？ -> [Z80命令セットの日本語解説](http://www.yamamo10.jp/yamamoto/comp/Z80/instructions/index.php)があるので読む。ネットの海にはなんでもある
