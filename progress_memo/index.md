# 実装の進捗

## 1日目

Rustの勉強のために、そして計算機というものを少しでも理解するために、Rustでゲームボーイのエミュレータを実装することにしました。

とりあえず見たサイトは[これ](https://keichi.dev/post/write-yourself-a-game-boy-emulator/)

主なドキュメントと方針が書かれているので、それを参考に作っていきます。  
ドキュメントについては[こちら](https://github.com/gbdev/awesome-gbdev)も詳しいです。

### 情報収集

[Game Boyについての有名な解説動画](https://media.ccc.de/v/33c3-8029-the_ultimate_game_boy_talk)を見て、ほーん分かったような分からんようなになりました。まず早口なので英語を理解するのが結構難しい。

[もう一つの基礎的な動画](https://www.youtube.com/playlist?list=PLu3xpmdUP-GRDp8tknpXC_Y4RUQtMMqEu)の方が初心者には良いかも。特に自作OSとかでCPUやアセンブリの基本的な知識を持っていない人はこちらをおすすめします。

### ROM読み取り

まずは何から手を付けようかと思ったが、先人がROMの読み取りから手を付けていたのにならい、ROMを読み出してくる部分から書くことにし、
[Pan DocsのROM説明部分](https://gbdev.io/pandocs/The_Cartridge_Header.html)を読みます。

読んだ結果どうもメモリマップの話とかをまず理解しなければならないねということがわかったので、まとめることに......。

#### Game Boyのメモリ戦略

前提として、Game Boyには8KiBのRAMと8KiBのVRAMが搭載されています......これが2003年まで製造販売されてたってマジ？ 翌年発売のDSは4MB RAMを搭載しているんですが。というかDSが4MBなのもすごいね。

まあそんなことはいいや。さて、Game Boyに搭載されているCPUには16bitのメモリバスが存在するので、64KiBまでのメモリアドレスを扱うことができます。RAM 8KiB + VRAM 8KiB = 16KiB なので、64KiB - 16KiB = 48KiB余りますね。その余った分をROMの読み込みやデバイスアクセス、スプライトの管理等に使用します。

以下は詳細なメモリマップです。[Pan Docs](https://gbdev.io/pandocs/Memory_Map.html)から引っ張ってきました。

| 開始位置  | 終了位置 | 内容                            | 備考                                                                  |
| -------- | -------- | ------------------------------ | --------------------------------------------------------------------- |
| 0000     | 3FFF     | 16 KiB ROM Bank 00              | バンク0(カートリッジ最初の16KiB)で固定                                 |
| 4000     | 7FFF     | 16 KiB ROM Bank 01~NN          | MBCによってバンクを切り替え可能                                       |
| 8000     | 9FFF     | 8 KiB Video RAM (VRAM)         | 画面表示に使用。ゲームボーイカラーではバンク切り替え可能              |
| A000     | BFFF     | 8 KiB External RAM             | カートリッジに増設されたRAMをコントロールする領域。バンク切り替え可能 |
| C000     | CFFF     | 4 KiB Work RAM (WRAM)          | メインメモリ                                                          |
| D000     | DFFF     | 4 KiB Work RAM (WRAM)          | メインメモリ。ゲームボーイカラーではバンク切り替え可能                |
| E000     | FDFF     | C000~DDFFのミラー (ECHO RAM)   | C000 から DDFF を読み込んだ時と同じ内容が出現する                     |
| FE00     | FE9F     | Sprite attribute table (OAM)   | スプライトの管理を行う領域                                            |
| FEA0     | FEFF     | Not Usable                     | Nintendoが使用を禁止している領域                                      |
| FF00     | FF7F     | I/O Registers                  | デバイスアクセス時に使用                                              |
| FF80     | FFFE     | High RAM (HRAM)                | スタック用の領域                                                      |
| FFFF     | FFFF     | Interrupt Enable register (IE) | 割り込みの有効/無効を切り替える                                        |

今回注目するべきなのは上二つです。そもそもROMにアクセスするアドレスが32KiBしか割り当てられていません。これは極めて狭い範囲です。  
ROM容量が32KiB以内に収まるのはテトリスのような極めてシンプルなゲームくらいで、ほとんどのゲームは32KiBを超過してしまいます。

例えばポケモン赤緑の国内版ROMの容量は512KiBですし、海外版に至ってはちょうど1MiBだそうです。どうやったってメモリバスが足りません。  
素直にやれば、最初の32KiB以降のROMの中身にアクセスすることは出来ないということになります。これはとても困りますね。

それを解決するためのTrickがMBCs, Memory Bank Controllersです。

Trickの方針はこうです。

1. 大きなROMを16KiBごとの区画に切り分ける
2. その区画に対し、前から0-indexedで番号を割り振る
3. 番号を指定すると、その番号が振られた区画のデータがMBCによって0x4000 ~ 0x7FFFの範囲にマッピングされる

この機能を使用することで、ROM上の任意の場所にあるデータを読み込むことが出来るようになります。

ところでMBCsは本来ROMカートリッジ内に実装されているチップで、厳密にいえばGame Boyの本体そのものには存在しないチップなのですが、これから作るのは物理カートリッジを扱わないエミュレータなので当然実装する必要があります。

#### Re:ROM読み取り

というわけでROM読み取りの実装に帰ってきました。張り切ってMBCを実装していく......のは少し辛いです。MBCにも色々な種類があり、それらを一つ一つ実装していくのは骨が折れます。  
出来なくはないでしょうが、一ヶ月使ってようやくROM読み取り部分が完成、みたいなことになってしまうでしょう。このような進め方ではモチベーションが萎びてしまう自信があります。

よって、今の段階では最も簡単なNo MBCのみに対応することにします。No MBCとはROMの中身を直接そのまま0x0000 ~ 0x7FFFにマッピングするだけの、最も単純なメモリ戦略です。
つまり、32KiBよりも大きいROMを扱うのは一旦後回しということですね。

インクリメンタルに進めていくのは大きいソフトウェアを作っていくうえでの定石ですし、また大きなROMを扱いたくなった時に戻ってくるとしましょう。

#### ROM読み込みの実装

とりあえずRomのヘッダ情報を格納します。rom.rsを作りました。Rust完全初心者なので[先駆者の実装](https://github.com/mj-hd/gb/)を参考に実装しています。便利な言語仕様が多すぎてちょっとびっくりしますね。

RustのドキュメントやGame Boyのドキュメントとにらめっこしながら手を動かすと読み取りは終わりました。考える時間よりは調べる時間の方がずっと長かったですね。

#### MBCの実装

MBCは、つまるところCPUのメモリバスとROMの仲立ちをするものなので、メモリバスのことも考えながら実装する必要があります。  
少し考えることが多くて厄介ですが、以下の要件を満たすように作れば良いと考えました。

- MBCのタイプによって挙動を切り替えることが出来る -> メソッドは共通になりそうなのでtraitを定義するのが良いかな？
- 必要なメソッドは以下の通り？

1. ROM-Reading
2. RAM-Reading
3. ROM-Writing (ROM-bankへの書き込み)
4. RAM-Writing

こんなもんですかねえと思いながら[先人の初期実装](https://github.com/mj-hd/gb/commit/e8a8b65d05c43b2c38bf627bb19be8f2e7299f1c)を覗いてみると大体同じだったので、実装していきます。とはいえNo MBCしか実装しないのでまあ楽。

Traitって何？ `impl Trait`と`impl Trait for struct`の意味するところが違うってどういうこと？ とか思いながら必死でRustのドキュメントを読みながら実装しました。出来るだけ写経せず、どうしても詰まった時だけ先人のコードを見るようにしましたが、想定より内容が一致しました。方針の立て方は合っているということなのでまあ良いことなのかなと。

とりあえず今回はここで終わり。次はメモリバスとCPUかなあ。
